<?php

/**
 * @file
 * Hooks and functionality for the Commerce Attribute module.
 */

use Drupal\entity\BundleFieldDefinition;
use Drupal\field\Entity\FieldStorageConfig;
use Drupal\Core\Form\FormStateInterface;
use Drupal\commerce_product\Entity\ProductType;
use Drupal\commerce_product\Entity\ProductVariationType;

/**
 * Implements hook_entity_type_alter().
 */
function commerce_attribute_entity_type_alter(&$entity_types) {
  $entity_types['commerce_product_attribute']->setClass('Drupal\commerce_attribute\Entity\ProductAttribute');
  $entity_types['commerce_product_attribute_value']->setClass('Drupal\commerce_attribute\Entity\ProductAttributeValue');
  $entity_types['commerce_product_attribute']->setFormClass('add', 'Drupal\commerce_attribute\Form\ProductAttributeForm');
  $entity_types['commerce_product_attribute']->setFormClass('edit', 'Drupal\commerce_attribute\Form\ProductAttributeForm');
  $entity_types['commerce_product_attribute_value']->setFormClass('add', 'Drupal\commerce_attribute\Form\ProductAttributeValueForm');
  $entity_types['commerce_product_attribute_value']->setFormClass('edit', 'Drupal\commerce_attribute\Form\ProductAttributeValueForm');
}

/**
 * Implements hook_ENTITY_TYPE_update().
 */
function commerce_attribute_commerce_product_attribute_value_update($attribute_value) {

  // Proceed only if price trait is enabled.
  if (!$attribute_value->hasField('price')) {
    return;
  }
  // Check if the attribute price is changed or not.
  // If its not changed, we do not have to perform the variation
  // price update process.
  $original_price = $attribute_value->original->get('price')->first()->toPrice();
  $new_price = $attribute_value->get('price')->first()->toPrice();
  if (!$new_price->compareTo($original_price)) {
    return;
  }
  // Updates the variation price associated with the attribute value.
  \Drupal::service('commerce_attribute.variation_price_handler')->updateProductVariationsPrice($attribute_value);
}

/**
 * Implements hook_ENTITY_TYPE_presave().
 */
function commerce_attribute_commerce_product_variation_presave($variation) {
  $variation_type = ProductVariationType::load($variation->bundle());
  // Proceed only if attribute based price trait is enabled.
  if (!$variation_type->hasTrait('commerce_attribute_variation_price')) {
    return;
  }

  // Updates the variation price to be the sum of its attributes which have has
  // price trait enabled.
  $new_price = \Drupal::service('commerce_attribute.variation_price_handler')->recalculateVariationPrice($variation);
  if (!empty($new_price)) {
    $variation->setPrice($new_price);
  }
}

/**
 * Implements hook_ENTITY_TYPE_presave().
 */
function commerce_attribute_commerce_product_variation_type_presave($variation_type) {
  $has_attribute_price_trait = $variation_type->hasTrait('commerce_attribute_variation_price');

  // Add base price field to product type if attribute pricing is enabled for
  // variation.
  $product_type = \Drupal::service('commerce_attribute.variation_price_handler')->getProductTypes($variation_type->id());
  $price_storage = FieldStorageConfig::loadByName('commerce_product', 'price');
  if (!$price_storage && $has_attribute_price_trait) {
    $field_definition = BundleFieldDefinition::create('commerce_price')
      ->setLabel(t('Price'))
      ->setRequired(TRUE)
      ->setDisplayOptions('form', [
          'settings' => [
            'display_label' => TRUE,
          ],
        ])
      ->setDisplayConfigurable('form', TRUE);
    $field_definition->setTargetEntityTypeId('commerce_product');
    $field_definition->setTargetBundle($product_type->id());
    $field_definition->setName('price');
    \Drupal::service('commerce.configurable_field_manager')->createField($field_definition);
  }
  elseif ($price_storage && !$has_attribute_price_trait) {
    FieldStorageConfig::loadByName('commerce_product', 'price')->delete();
  }
}

/**
 * Implements hook_form_alter().
 */
function commerce_attribute_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  if (substr($form_id, 0, 26) == 'commerce_product_variation') {
    $product = \Drupal::routeMatch()->getParameter('commerce_product');
    if (empty($product)) {
      return;
    }

    $product_type = ProductType::load($product->bundle());
    $variation_type = ProductVariationType::load($product_type->getVariationTypeId());
    // Proceed only if attribute based price trait is enabled.
    if (!$variation_type->hasTrait('commerce_attribute_variation_price')) {
      return;
    }

    // Disable the price field if attribute price trait is enabled for variation
    // type. The variation price will be calculated based on the attributes
    // and the base product price.
    $form['price']['widget']['0']['#disabled'] = TRUE;
    $form['price']['widget']['0']['#description'] = t('Prices are calculated from the
      product base price and the attributes price');

    // Set the default value for price field if its a add form.
    $current_route_name = \Drupal::routeMatch()->getRouteName();
    if ($current_route_name == 'entity.commerce_product_variation.add_form') {
      // Set the default value for price field as the product base price
      // for add form.
      $form['price']['widget']['0']['#default_value'] = $product->get('price')
        ->first()
        ->toPrice()
        ->toArray();
    }
  }
}
