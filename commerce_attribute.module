<?php

/**
 * @file
 * Hooks and functionality for the Commerce Attribute module.
 */

use Drupal\entity\BundleFieldDefinition;

/**
 * Implements hook_entity_type_alter().
 */
function commerce_attributes_entity_type_alter(&$entity_types) {
  $entity_types['commerce_product_attribute']->setClass('Drupal\commerce_attributes\Entity\ProductAttribute');
  $entity_types['commerce_product_attribute_value']->setClass('Drupal\commerce_attributes\Entity\ProductAttributeValue');
  $entity_types['commerce_product_attribute']->setFormClass('add', 'Drupal\commerce_attributes\Form\ProductAttributeForm');
  $entity_types['commerce_product_attribute']->setFormClass('edit', 'Drupal\commerce_attributes\Form\ProductAttributeForm');
  $entity_types['commerce_product_attribute_value']->setFormClass('add', 'Drupal\commerce_attributes\Form\ProductAttributeValueForm');
  $entity_types['commerce_product_attribute_value']->setFormClass('edit', 'Drupal\commerce_attributes\Form\ProductAttributeValueForm');
}

/**
 * Implements hook_ENTITY_TYPE_update().
 */
function commerce_attributes_commerce_product_attribute_value_update($attribute_value) {

  // Proceed only if price trait is enabled.
  if (!$attribute_value->hasField('price')) {
    return;
  }
  // Check if the attribute price is changed or not.
  // If its not changed, we do not have to perform the variation
  // price update process.
  $attribute_value_original = $attribute_value->original;
  $original_price = $attribute_value_original->get('price')->first()->toPrice()->getNumber();
  $new_price = $attribute_value->get('price')->first()->toPrice()->getNumber();
  if ($new_price == $original_price) {
    return;
  }

  // Updates the variation price associated with the attribute value.
  $price_handler = \Drupal::service('commerce_attributes.variation_price_handler');
  $price_handler->updateProductVariationsPrice($attribute_value);
}

/**
 * Implements hook_ENTITY_TYPE_update().
 */
function commerce_attributes_commerce_product_variation_presave($variation) {
  $bundle_entity_type_id = $variation->getEntityType()->getBundleEntityType();
  $variation_type = \Drupal::service('entity_type.manager')->getStorage($bundle_entity_type_id)->load($variation->bundle());
  // Proceed only if attribute based price trait is enabled.
  if (!$variation_type->hasTrait('commerce_attribute_variation_price')) {
    return;
  }
  // Updates the variation price to be the sum of its attributes which have has
  // price trait enabled.
  $price_handler = \Drupal::service('commerce_attributes.variation_price_handler');
  $product_type = $price_handler->getProductTypes($variation_type->id());
  $product = $variation->get('product_id')->entity;

  // Create price field to the product bundle if it does not exists already.
  if (!$product->hasField('price')) {
    $field_definition = BundleFieldDefinition::create('commerce_price')
      ->setLabel(t('Price'))
      ->setRequired(TRUE);
    $field_definition->setTargetEntityTypeId('commerce_product');
    $field_definition->setTargetBundle($product->bundle());
    $field_definition->setName('price');
    \Drupal::service('commerce.configurable_field_manager')->createField($field_definition);
  }

  $new_price = $price_handler->getProductVariationPrice($variation);
  if (!empty($new_price)) {
    $variation->setPrice($new_price);
  }
}
